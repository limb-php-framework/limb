====== Cредства для подключения классов и поддержки отложенной загрузки кода ======




===== Подключение классов Limb3 и autoload =====

В Limb3 используется схема размещения классов по файлам: **1 класс - 1 файл**. Файлы классов имеют суффикс .class.php. В Limb3 используется специализированная версия require_once - **lmb_require**, которая учитывает эту специфику хранения классов в проекте Limb3 и на этой основе позволяет загружать код классов отложенно через механизм _ _autoload. 

Например:
<code php>
lmb_require('limb/web_app/src/controller/lmbController.class.php');
</code>

Класс lmbController не будет подключен прямо сейчас, он лишь будет помечен для включения через механизма autoload, и будет реально подключен только в случае его реального использования.

За отложенную загрузку классов отвечает функция **lmb_autoload**, которая автоматически регистрируется в качестве autoload-хелдлера при включении файла limb/core/common.inc.php

Использовать lmb_require в своем коде, использующем Limb3, совершенно необязательно, эта функция прозрачна и полностью аналогична встроенным в PHP require_once, include_once аналогам. Однако, если вы заинтересованы в отложенной загрузке кода, то к этой функции стоит присмотреться. К тому, же lmb_require поддерживает glob модификаторы (см. [[global_functions|список глобальных функции Limb3]]), например: 
lmb_require('src/model/*.class.php');

===== Зачем lmb_require, если используется autoload? =====

В свое время у нас был соблазн полностью отказаться от явного подключения кода и полностью переложить эту функцию на механизм _autoload, однако очень быстро были выявлены недостатки:

  * В коде стало непонятно, откуда именно, из какого пакета подключается тот или иной класс
  * Мы не используем схему хранения классов, схожую с PEAR, где путь до файла фактически отражается в названии класса, поэтому пришлось разработать крайне негибкую схему индексации всех классов
  * framework не должен навязывать обязательной зависимости от _autoload, у разработчика могут быть причины против использования подобной схемы или персональные предпочтения по ее использованию
  * Разработчик, возможно, больше предпочитает иную схему хранения классов, не по схеме "один класс = один файл", например, в виде модулей. В этом случае использование _autoload крайне затруднено.

Поэтому, взвесив все "за" и "против", мы, на наш взгляд, нашли компромисс в виде функции lmb_require. Эта функция в случае подключения классов/интерфейсов, по сути, не производит включения PHP кода, а лишь внутренне помечает, что данный класс расположен в таком файле. Далее эта информация используется в _autoload хендлере lmb_autoload, как только данный класс понадобится. При подключении же PHP модулей эта функция работает аналогично include_once.
 
