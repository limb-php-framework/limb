====== Компиляция и выполнение шаблона. Пример рендеринга MACRO-шаблона ======
===== Фаза компиляции и фаза исполнения шаблонов =====

Шаблонизатор **[[..:Macro|Macro]]** - является **компилирующим обработчиком**. То есть на основе базового шаблона создается php-скрипт, который записывается на диск, затем этот скрипт подключается и исполняется. Это дает значительное преимущество в скорости работы ввиду того, что php-скрипт создается только 1 раз и затем только исполняется, а также в том, что скомпилированные шаблоны могут кэшироваться php-акселераторами, например, eAccelerator.

Другими словами MACRO-шаблоны обрабатываются в 2 стадии
  * **фаза компиляции (CompileTime)**
  * **фаза исполнения (RunTime)**

Так как фаза компиляции является достаточно "тяжелой" с точки зрения скорости выполнения, при помощи опции файла macro.conf.php (или при помощи параметров конструктора lmbMacroConfig, если вы используете MACRO без пакета VIEW) вы можете запретить перекомпиляцию шаблона на каждый вызов. О том  как это сделать см. раздел "Рендеринг MACRO шаблона".

Обычно фаза компиляции нужна только в то время, когда вы создаете шаблон, во время разработки приложения, то есть тогда, когда шаблон активно исправляется. На рабочей же копии приложения, компиляцию отключают. То есть шаблонная система, однажды скомпилировав шаблон, уже не будет делать это повторно.

Скомпилированные шаблоны хранятся обычно в папке /var/compiled вашего приложения

===== Компиляция шаблона =====

Во время компиляции шаблон разбирается, и создается дерево элементов шаблона, наподобие DOM. Элементы этого дерева называются элементами (нодами) дерева компиляции (lmbMacroNode). Элементами этого дерева являются MACRO-теги и MACRO-выражения шаблона.

MACRO предоставляет широкие возможности по повторному использование шаблонов: 
  * **включение** (include), то есть вставка другого шаблона в текущий шаблон и 
  * **обворачивание** (wrap), то есть вставка текущего шаблона или его части внутрь другого шаблона. 

Это накладывает свой отпечаток на процесс компиляции. **MACRO шаблон компилируется всегда только целиком**. Это очень важно понимать! Поясним: если шаблон является составным, то есть включает другие шаблоны или же сам включается в другой шаблон, то компиляция производится в 2 этапа:
  - сначала создается общий шаблон, 
  - потом общий шаблон компилируется 

На самом деле это процесс немного сложнее, однако на данном этапе можно понимать компиляцию именно так. Подробнее об этом в разделе [[template_composition|"Композиция шаблонов"]].

Из-за этих особенностей MACRO не может поддерживать режим перекомпиляции при изменении только базового шаблона, как это имеет место в Smarty - ведь любая часть составного шаблона может быть изменена, а проверять все составляющие слишком накладно.

После сборки дерева производится обход всех его элементов (тегов, выражений, фильтров), каждый из которых выдает свою порцию php-скрипта откомпилированного шаблона.

Откомпилированный MACRO-шаблон - это готовый к запуску php-скрипт, содержащий класс с уникальным именем. см. пример откомпилированного шаблона ниже.


===== MACRO-шаблон: компиляция и запуск =====

Рассмотрим MACRO-шаблон:
<code xml>
<body>
<h1>Newsline</h1>
 
{{list using="$#news"}}
<ul>     
  {{list:item}}
    <li>[{$item.date}] <b>{$item.title|html}</b> </li>
  {{/list:item}}
</ul>
{{/list}}
</body>
</code>

Назовем этот шаблон news.phtml и положим его в папку **templates**.

Вот код, который можно использовать для запуска этого шаблона. Мы предполагаем, что шаблон имеет имя news.html и хранится в подпапке templates в той папке, где лежит этот php-скрипт:
<code php>
<?php

set_include_path(dirname(__FILE__) . '/' . PATH_SEPARATOR .
                '/path/to/limb/' . PATH_SEPARATOR .
                get_include_path());

require_once('limb/macro/common.inc.php');

$config = new lmbMacroConfig($cache_dir = dirname(__FILE__ ) . '/cache/',
                             $is_force_compile = false,
                             $is_force_scan = false,
                             $tpl_scan_dirs = dirname(__FILE__) . '/templates/');

$macro = new lmbMacroTemplate('news.phtml', $config);

$test_news = array(array('date' => '2007-01-12', 'title' => 'test news1'),
                          array('date' => '2007-01-13', 'title' => 'test news2'));
                          
$macro->set('news', $test_news);
echo $macro->render();

?>
</code>

Назовем этот php-скрипт - macro_test.php. Для успешного выполнения этого скипта необходимо создать папку cache и проставить в ней соответствующие права на запись. 

После запуска macro_test.php мы должны получить следующий HTML-код:
<code>
<body>
<h1>Newsline</h1>
<ul>
    <li>[2007-01-12] <b>test news1</b> </li>
    <li>[2007-01-13] <b>test news2</b> </li>
</ul>
</body>
</code>

Скомпилированный MACRO-шаблон будет выглядеть следующим образом (форматирование изменено). Вы можете найти этот файл в папке /cache:
<code php>
<?php
if(!class_exists('MacroTemplateExecutor47662db85cf6e', false))
{
require_once('limb/macro/src/compiler/lmbMacroTemplateExecutor.class.php');
class MacroTemplateExecutor47662db85cf6e extends lmbMacroTemplateExecutor 
{
  function render($args = array()) 
  {
    if($args) extract($args);
    $this->_init();
     ?>
    <body>
    <h1>Newsline</h1>
     
    <?php $C = 0;$D = $this->news;
    foreach($D as $item) {
      if($C == 0) { ?>
      <ul>     
      <?php } ?>
      
      <li>[<?php $F='';
      $G = $item;
      if((is_array($G) || ($G instanceof ArrayAccess)) && isset($G['date'])) { 
        $F = $G['date'];
      }else{ 
        $F = '';
      }
      echo $F;
       ?>] <b><?php $H='';
      $I = $item;
      if((is_array($I) || ($I instanceof ArrayAccess)) && isset($I['title'])) { 
        $H = $I['title'];
      }else{ 
        $H = '';
      }
      echo htmlspecialchars($H,3);
       ?></b> </li>
        <?php $C++;} ?>
        
      <?php if($C > 0) { ?>
      </ul>
    <?php } ?>
    
    </body>
    <?php 
    }
  }
}
$macro_executor_class='MacroTemplateExecutor47662db85cf6e';
</code>

===== Класс lmbMacroTemplate =====

Методы класса lmbMacroTemplate :
    * set($var, $value) - ставит в шаблон одну переменную. Эта переменная будет доступна в шаблоне в виде $this->var или $#var.
    * setVars($vars) - ставит в шаблон группу переменных. Затирает ранее проставленные переменные.
    * render() - выполняет шаблон и возвращает результат.

Конструктор lmbMacroTemplate получает следующие параметры:
    * template_path - путь до шаблона
    * $config - объект класс lmbMacroCofig. Если параметр не указан, то используется lmbMacroConfig c параметрами по-умолчанию.
    * $locator - объект класса lmbMacroTemplateLocator или иного класса, поддерживающий тот же интерфейс. Если параметр не указан, то используется lmbMacroTemplateLocator, который в конструктор получает объект $config.


===== Дополнительная информация =====

  * Раздел [[.compiler|"Как работает компилятор MACRO-шаблонов"]] - дает подробную информацию о том, как компилируется MACRO-шаблон. Этот материал рекомендуется разработчикам, которые желают узнать как работает компилятор MACRO-шаблонов, в частности для того, чтобы создать свой тег или фильтр.