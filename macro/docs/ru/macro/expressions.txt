====== Выражения. Вывод значений переменных в шаблоне. ======

Данная страница предполагает, что Вам знакомы следующие понятия:
  * что такое выражения и фильтры. Начальные сведения об этих элементах можно получить из раздела [[.intro|"Введение в шаблонную систему MACRO. Основные элементы шаблонов"]]



===== Общий вид выражений. =====

**Выражения** - это специальные конструкции шаблонной системы MACRO, которые имеют 2 основных назначения:

  - **для вывода значений переменных**:
    * {$percentage} - простой вывод переменной из локального контекста. Эквивалентно <? echo $percentage; ?>
    * {$#percentage} - вывод переменной из контекста шаблона. Эквивалентно <? echo $this->percantage; ?>
    * {$item.title} - вывод переменной по пути. Эквивалентно приблизительно следующему <? $var_001 = isset($item['title']) ? $item['title'] : ""; echo $var_001; ?>
  - **формируют динамические значения тегов**
    * {{input id="title_{$index}"}}

То есть применение выражений зависит от ситуации: если выражение стоит просто в шаблоне и не является атрибутом MACRO-тега, тогда это - аналог echo, то есть оно выводит значение выражения. Если же выражение является атрибутом MACRO-тега, то это по сути просто какое-то значение, используемое в операции конкатенации.

Выражения также позволяют применять к значениям специальные **фильтры**, то есть модифицировать значения.

Итак, выражения имеют общий вид: {$Expression[|filter1|filterN]}, где:
  * {$...} - знак самого выражения.
  * Expression - имя переменной или путь до нее, которую необходимо вывести или использовать ее значение.
  * filter1, filterN - фильтры, применяемые к данным. Несколько фильтров разделяются вертикальными чертами.

===== Выражения, содержащие пути до переменной =====

Выражения вида {$item.title} - это выражения, содержащие путь до переменной. MACRO разбивает такие выражения на составляющие и для каждого элемента путь генерит нечто вроде:
<code php>
if((is_array($sub_var1) || $sub_var1 instanceof ArrayAccess) && isset($sub_var1[$stepN])) 
  $sub_var2 = $sub_var1[$step2]; 
else 
  $sub_var2 = "";
</code>

Где $sub_varN - какая-то временная переменная, а $stepN - очередной участок пути. При выполнении шаблона, если на каком-то участке дальше по цепочке идти будет невозможно ($sub_var[$stepN] не существует или $sub_var стала скаляром или объектом, не поддерживающим ArrayAccess), тогда получение данных по цепочке обрывается и будет выведено пустое значение.

===== Выражения, содержащие вызовы методов =====

MACRO-выражения также поддерживают вызовы методов или обращение к атрибутам объектов напрямую, например:

{$#some_object->someMethod()}

Ничего не мешает передать в метод любые параметры:

{$#some_object->someMethod("aaa", $#foo)}

Обратите внимание, что $#foo - это аналог $this->foo. Преобразование $#foo в $this->foo MACRO делает автоматически.

При этом после вызова метода можно продолжать писать выражение, как обычно, например {$#book->getAuthor().full_name}, то в шаблоне условно будет иметь вид:

<code php>
$temp_var = $this->book->getAuthor();
if((is_array($temp_var) || $temp_var instanceof ArrayAccess) && isset($temp_var['full_name'])) 
  $sub_var = temp_var['full_name']; 
else 
  $sub_var = "";
</code>

===== Выражения и фильтр html по-умолчанию =====

По-умолчанию, MACRO применяет фильтр html (функция htmlspecialchars()) для всех выражений, которые не содержат ни одного фильтра. Если применение html-фильтра в каком-то конкретном месте нежелательно, тогда используйте фильтр raw, который ничего не делает, а лишь отменяет применение html-фильтра по-умолчанию.

Итак, применение html-фильтра
  * {$title} - применит
  * {$title|raw} - не применит, так как указан хотя бы один фильтр
  * {$title|html} - применит, так как указан явно
  * {$title|trim} - не применит, так как указан хотя бы один фильтр
  * {$title|trim|html} - применит, так как указан явно
