# Выражения. Вывод значений переменных в шаблоне
Данная страница предполагает, что Вам знакомы следующие понятия:

* что такое выражения и фильтры. Начальные сведения об этих элементах можно получить из раздела [«Введение в шаблонную систему MACRO. Основные элементы шаблонов»](./intro.md)

## Общий вид выражений
**Выражения** — это специальные конструкции шаблонной системы MACRO, которые имеют 2 основных назначения:

1. для вывода значений переменных:
  * {$percentage} — простой вывод переменной из локального контекста. Эквивалентно <? echo $percentage; ?>
  * {$#percentage} — вывод переменной из контекста шаблона. Эквивалентно <? echo $this→percantage; ?>
  * {$item.title} — вывод переменной по пути. Эквивалентно приблизительно следующему <? $var_001 = isset($item['title']) ? $item['title'] : »»; echo $var_001; ?>
2. формируют динамические значения тегов
 * {{input id=«title_{$index}»}}

То есть применение выражений зависит от ситуации: если выражение стоит просто в шаблоне и не является атрибутом MACRO-тега, тогда это - аналог echo, то есть оно выводит значение выражения. Если же выражение является атрибутом MACRO-тега, то это по сути просто какое-то значение, используемое в операции конкатенации.

Выражения также позволяют применять к значениям специальные **фильтры**, то есть модифицировать значения.

Итак, выражения имеют общий вид: {$Expression[|filter1|filterN]}, где:

* {$…} — знак самого выражения.
* Expression — имя переменной или путь до нее, которую необходимо вывести или использовать ее значение.
* filter1, filterN — фильтры, применяемые к данным. Несколько фильтров разделяются вертикальными чертами.

## Выражения, содержащие пути до переменной
Выражения вида {$item.title} — это выражения, содержащие путь до переменной. MACRO разбивает такие выражения на составляющие и для каждого элемента путь генерит нечто вроде:

    if((is_array($sub_var1) || $sub_var1 instanceof ArrayAccess) && isset($sub_var1[$stepN])) 
      $sub_var2 = $sub_var1[$step2]; 
    else 
      $sub_var2 = "";

Где $sub_varN — какая-то временная переменная, а $stepN — очередной участок пути. При выполнении шаблона, если на каком-то участке дальше по цепочке идти будет невозможно ($sub_var[$stepN] не существует или $sub_var стала скаляром или объектом, не поддерживающим ArrayAccess), тогда получение данных по цепочке обрывается и будет выведено пустое значение.

## Выражения, содержащие вызовы методов
MACRO-выражения также поддерживают вызовы методов или обращение к атрибутам объектов напрямую, например:

    {$#some_object→someMethod()}

Ничего не мешает передать в метод любые параметры:

    {$#some_object→someMethod(«aaa», $#foo)}

Обратите внимание, что $#foo — это аналог $this→foo. Преобразование $#foo в $this→foo MACRO делает автоматически.

При этом после вызова метода можно продолжать писать выражение, как обычно, например {$#book→getAuthor().full_name}, то в шаблоне условно будет иметь вид:

    $temp_var = $this->book->getAuthor();
    if((is_array($temp_var) || $temp_var instanceof ArrayAccess) && isset($temp_var['full_name'])) 
      $sub_var = temp_var['full_name']; 
    else 
      $sub_var = "";

## Выражения и фильтр html по-умолчанию
По-умолчанию, MACRO применяет фильтр html (функция htmlspecialchars()) для всех выражений, которые не содержат ни одного фильтра. Если применение html-фильтра в каком-то конкретном месте нежелательно, тогда используйте фильтр raw, который ничего не делает, а лишь отменяет применение html-фильтра по-умолчанию.

Итак, применение html-фильтра

* {$title} — применит
* {$title|raw} — не применит, так как указан хотя бы один фильтр
* {$title|html} — применит, так как указан явно
* {$title|trim} — не применит, так как указан хотя бы один фильтр
* {$title|trim|html} — применит, так как указан явно
