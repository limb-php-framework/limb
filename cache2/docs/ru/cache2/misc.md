# Дополнительные возможности пакета CACHE2
## Борьба с конкурентностью при генерировании кэша
Борьбу с так называемым [dog-pile эффектом](http://www.opennet.ru/base/dev/memcached_lock.txt.html) реализует lmbMintCache Реализация идет через введение окна генерации для кэша.

Важно помнить, что нельзя прозрачно переключиться с использования lmbMintCache назад к lmbCache, т.к. они хранят разные структуры данных. lmbMintCache кроме данных в ключе хранит дополнительный ttl. переключиться с lmbCache на lmbMintCache можно, но только если вы не храните в кэше массивы данных

lmbMintCache определяет время «протухания» кэша своими средствами, не зависящими от средств контроля ttl хранилища. Для этого в сохраняется структура вида array($cached_value, $ttl)

lmbMintCache оперирует несколькими ttl:

    function __construct($cache, $default_ttl = 300, $fake_ttl = 86400, $cooled_ttl = 60)

* $default_ttl — ttl для хранения кэша
* $fake_ttl — ttl, который передается хранилищу как время жизни структуры в хранилище. обычно это время заведомо много больше чем нужное время актуальности кэша
* $cooled_ttl — время, «охлаждения» кэша. его нужно выставлять небольшим, но достаточным для перегенерации кэша. т.е. в это то время, когда остальные процессы все еще будут довольствоваться старыми данными, а процесс генерации будет формировать новые.

### lmbMintCache->add, lmbMintCache->set
работают аналогично lmbCache, но в хранилищу передается fake_ttl, а в качестве значения сохраняется массив из значения и переданного (или дефолтного ttl).

### lmbMintCache->get
особый интерес представляет поведение метода get. из кэша достается структура и проверяется время ее жизни. если оно удовлетворительное — то просто возвращается значение. Eсли же время жизни значения истекло, то:

* Это же значение записывается в хранилище с небольшим временем жизни $cooled_ttl
* клиенту, вызвавшему метод, возвращается NULL

Таким образом вызывающий скрипт прозрачно получит уведомление, что нужного значения в кэша нет, и будет иметь некоторое время на генерацию нужного значения и сохранения его в кэш. В то время остальные клиенты смогут довольствоваться некоторое время старыми данными из кэша, т.к. для них он будут выглядеть валидными.

Если же скрипт, получивший NULL, не перегенерирует кэш по какимто причинам, то через время $cooled_ttl кэш станет невалидным для остальных клиентов или будет вытеснен из хранилища по expiration time.

### lmbMintCache->coolDownKey($key)

Метод позволяет «охладить» кэш, т.е. инвалидировать его таким образом, чтобы процесс его новой генерации снова не попал в race condition.

в этом методе значение из кэша перезаписывается с невалидным логическим ttl (время в прошлом), и с небольшим $cooled_ttl для хранилища.

таким образом если в одном процессе вы вызовете $cache→coolDownKey($key). то другой процесс обращаясь через метод $cache→get($key) сможет организовать окно для генерации новых данных, и при этом обеспечить конкурентные процессы старыми данными из кэша на некоторое время.

## Организация группы кэшей с помощью тэгов

    class lmbTaggableCache implements lmbCache
    {
      function add($key, $value, $ttl = false, $tags_keys = 'default')
      function set($key, $value, $ttl = false, $tags_keys = 'default')
      function get($key)
      function delete($key)
      function deleteByTag($tag)
      function flush()
    }

lmbTaggableCache позволяет организовывать кэши в группы для удобства инвалидирования группы кэшэй. Mеханизм основан на том, что в кэше хранится хранится структура - переданное значение, и кроме него массив связанных с ним тэгов и их версия. Кроме того для каждого тэга в хранилище ведется запись о его текущей версии.

* Добавление в кэш значения с новым тэгом добавляет запись о том, что тэг имеет версию 0.
* Вызов метода deleteByTag($tag) вызывает инкремент версии тэга.
* Вызов get($key) достает из кэша структуру, и для каждого тэга производит сопоставление хранимой версии и текущей. если версии не совпадают - то кэш считается невалидным и клиент получает NULL.

## Профилирование запросов к кэшу
